<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quosz - Decentralized E2EE Chat</title>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.4.39.0.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, sans-serif; 
            background: #0f172a; 
            color: #e2e8f0; 
            min-height: 100vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            padding: 16px; 
            animation: fadeIn 0.5s ease-out; 
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideIn { from { transform: translateX(-20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        .container { max-width: 800px; width: 100%; }
        .form-container, .app-container { 
            background: #1e293b; 
            padding: 24px; 
            border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); 
        }
        .form-container { 
            text-align: center; 
            animation: slideUp 0.5s ease-out; 
        }
        input { 
            background: #334155; 
            color: #e2e8f0; 
            padding: 12px; 
            border-radius: 8px; 
            border: none; 
            width: 100%; 
            margin: 8px 0; 
            font-size: 16px; 
            outline: none; 
            transition: background 0.3s ease, transform 0.2s ease; 
        }
        input:focus { background: #475569; transform: scale(1.02); }
        button { 
            background: #3b82f6; 
            color: white; 
            padding: 12px 24px; 
            border-radius: 8px; 
            border: none; 
            cursor: pointer; 
            font-size: 16px; 
            transition: background 0.3s ease, transform 0.2s ease; 
        }
        button:hover { background: #2563eb; transform: scale(1.05); }
        button:active { transform: scale(0.95); }
        .app-container { display: none; animation: slideUp 0.5s ease-out; }
        .search-bar { 
            display: flex; 
            gap: 8px; 
            margin-bottom: 16px; 
        }
        .user-list { list-style: none; }
        .user-list li { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            padding: 12px; 
            background: #334155; 
            border-radius: 8px; 
            margin: 8px 0; 
            cursor: pointer; 
            transition: background 0.3s ease, transform 0.2s ease, opacity 0.3s ease; 
            animation: slideIn 0.3s ease-out forwards; 
        }
        .user-list li:hover { background: #475569; transform: scale(1.02); }
        .user-list li.hidden { opacity: 0; height: 0; margin: 0; overflow: hidden; }
        .avatar { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            object-fit: cover; 
            transition: transform 0.3s ease; 
        }
        .avatar:hover { transform: scale(1.1); }
        .chat-box { 
            height: 400px; 
            background: #1e293b; 
            border-radius: 8px; 
            padding: 16px; 
            overflow-y: auto; 
            margin-bottom: 16px; 
            scroll-behavior: smooth; 
        }
        .message { 
            margin: 8px 0; 
            animation: slideIn 0.3s ease-out; 
        }
        .own { text-align: right; color: #3b82f6; }
        .typing { font-style: italic; color: #64748b; animation: pulse 1.5s infinite; }
        .chat-input { 
            display: flex; 
            gap: 8px; 
        }
        .chat-input input { flex: 1; }
        .status { color: #94a3b8; font-size: 14px; margin-top: 8px; transition: opacity 0.3s ease; }
        .error { color: #ef4444; animation: slideUp 0.3s ease-out; }
    </style>
</head>
<body>
    <div class="container">
        <div id="form" class="form-container">
            <h1 class="text-2xl font-bold mb-4">Welcome to Quosz</h1>
            <p class="mb-4">Create your decentralized account</p>
            <input type="text" id="username" placeholder="Username (min 3 chars)" maxlength="20">
            <input type="file" id="photo" accept="image/*" class="mb-4">
            <button onclick="createAccount()">Create Account</button>
            <p class="mt-2 text-sm">Have an account? <a href="#" onclick="loadAccount()" class="text-blue-400 hover:text-blue-300 transition-colors">Load</a></p>
            <p id="error" class="error"></p>
        </div>
        <div id="app" class="app-container">
            <div class="flex items-center gap-4 mb-4">
                <img id="userAvatar" class="avatar" src="https://via.placeholder.com/40" alt="Avatar">
                <h2 id="userInfo" class="font-semibold"></h2>
            </div>
            <div class="search-bar">
                <input type="text" id="search" placeholder="Search users to chat..." onkeyup="searchUsers()">
            </div>
            <ul id="users" class="user-list"></ul>
            <div id="chat" class="chat-box"></div>
            <div class="chat-input">
                <input type="text" id="message" placeholder="Type a message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">Send</button>
            </div>
            <div id="status" class="status"></div>
        </div>
    </div>

    <script>
        // Global vars
        let currentUser = { username: '', id: '', photo: '' };
        let pubnub, localPeer, dataChannel, connectedPeer = null;
        let onlineUsers = {};
        let typingTimer;

        // UUID generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // Account creation
        async function createAccount() {
            const username = document.getElementById('username').value.trim();
            const photoInput = document.getElementById('photo');
            const error = document.getElementById('error');

            // Validate username
            if (username.length < 3) {
                error.textContent = 'Username must be at least 3 characters';
                return;
            }
            const existingUsers = JSON.parse(localStorage.getItem('quoszUsers') || '[]');
            if (existingUsers.includes(username)) {
                error.textContent = 'Username already taken';
                return;
            }

            // Handle photo
            let photo = '';
            if (photoInput.files[0]) {
                photo = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(photoInput.files[0]);
                });
            }

            // Save account
            currentUser = { username, id: generateUUID(), photo };
            localStorage.setItem('quoszUser', JSON.stringify(currentUser));
            localStorage.setItem('quoszUsers', JSON.stringify([...existingUsers, username]));
            startApp();
        }

        function loadAccount() {
            const user = JSON.parse(localStorage.getItem('quoszUser') || '{}');
            if (!user.username) {
                document.getElementById('error').textContent = 'No account found';
                return;
            }
            currentUser = user;
            startApp();
        }

        function startApp() {
            document.getElementById('form').style.display = 'none';
            document.getElementById('app').style.display = 'block';
            document.getElementById('userInfo').textContent = `${currentUser.username} (${currentUser.id})`;
            if (currentUser.photo) document.getElementById('userAvatar').src = currentUser.photo;
            initSignaling();
            updateStatus('Online. Search for users to chat.');
        }

        // Signaling
        function initSignaling() {
            pubnub = new PubNub({
                publishKey: 'demo',
                subscribeKey: 'demo',
                channel: 'quosz_signal'
            });
            pubnub.addListener({ message: m => handleSignal(m.message) });
            pubnub.subscribe({ channels: ['quosz_signal'] });

            setInterval(() => {
                pubnub.publish({
                    channel: 'quosz_signal',
                    message: { type: 'online', user: currentUser, socketId: Date.now() }
                });
                updateOnlineUsers();
            }, 5000);
        }

        function updateOnlineUsers() {
            const usersList = document.getElementById('users');
            usersList.innerHTML = '';
            Object.values(onlineUsers).forEach((user, index) => {
                if (user.username !== currentUser.username) {
                    const li = document.createElement('li');
                    li.style.animationDelay = `${index * 0.05}s`;
                    li.innerHTML = `<img src="${user.photo || 'https://via.placeholder.com/40'}" class="avatar"> ${user.username}`;
                    li.onclick = () => startChat(user);
                    usersList.appendChild(li);
                }
            });
        }

        function searchUsers() {
            const query = document.getElementById('search').value.toLowerCase();
            document.querySelectorAll('.user-list li').forEach(li => {
                const isVisible = li.textContent.toLowerCase().includes(query);
                li.classList.toggle('hidden', !isVisible);
            });
        }

        // WebRTC
        function startChat(targetUser) {
            connectedPeer = targetUser;
            updateStatus(`Connecting to ${targetUser.username}...`);
            createPeerConnection();
            pubnub.publish({
                channel: 'quosz_signal',
                message: { type: 'offer', from: currentUser, to: targetUser, offer: localPeer.localDescription }
            });
        }

        function createPeerConnection() {
            localPeer = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            localPeer.onicecandidate = e => {
                if (e.candidate) {
                    pubnub.publish({
                        channel: 'quosz_signal',
                        message: { type: 'ice', from: currentUser, to: connectedPeer, candidate: e.candidate }
                    });
                }
            };
            dataChannel = localPeer.createDataChannel('chat');
            setupDataChannel();
            localPeer.createOffer().then(offer => localPeer.setLocalDescription(offer));
        }

        function setupDataChannel() {
            dataChannel.onopen = () => updateStatus('Connected! Chat securely.');
            dataChannel.onmessage = async e => {
                const decrypted = await decryptMessage(e.data);
                if (decrypted !== '...') addMessage(decrypted, false);
                if (decrypted === '...') showTyping(false);
            };
            dataChannel.onclose = () => updateStatus('Connection closed.');
        }

        function handleSignal(msg) {
            if (msg.to?.username !== currentUser.username) return;
            if (msg.type === 'offer') {
                createPeerConnection();
                localPeer.setRemoteDescription(new RTCSessionDescription(msg.offer));
                localPeer.createAnswer().then(answer => {
                    localPeer.setLocalDescription(answer);
                    pubnub.publish({
                        channel: 'quosz_signal',
                        message: { type: 'answer', from: currentUser, to: msg.from, answer }
                    });
                });
            } else if (msg.type === 'answer') {
                localPeer.setRemoteDescription(new RTCSessionDescription(msg.answer));
            } else if (msg.type === 'ice') {
                localPeer.addIceCandidate(new RTCIceCandidate(msg.candidate));
            } else if (msg.type === 'online') {
                onlineUsers[msg.socketId] = msg.user;
                updateOnlineUsers();
            }
        }

        // E2EE
        async function deriveKey() {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw', enc.encode(currentUser.username + connectedPeer.username),
                { name: 'PBKDF2' }, false, ['deriveBits']
            );
            return crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: enc.encode('quosz_salt'), iterations: 100000, hash: 'SHA-256' },
                keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']
            );
        }

        async function encryptMessage(msg) {
            const key = await deriveKey();
            const enc = new TextEncoder();
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(msg));
            return btoa(String.fromCharCode(...new Uint8Array([...iv, ...new Uint8Array(encrypted)])));
        }

        async function decryptMessage(encryptedB64) {
            const key = await deriveKey();
            const data = Uint8Array.from(atob(encryptedB64), c => c.charCodeAt(0));
            const iv = data.slice(0, 12);
            const encrypted = data.slice(12);
            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
            return new TextDecoder().decode(decrypted);
        }

        // UI
        async function sendMessage() {
            const msg = document.getElementById('message').value.trim();
            if (!msg || !dataChannel || dataChannel.readyState !== 'open') return;
            const encrypted = await encryptMessage(msg);
            dataChannel.send(encrypted);
            addMessage(msg, true);
            document.getElementById('message').value = '';
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
            clearTimeout(typingTimer);
            dataChannel?.send(encryptMessage('...').then(enc => dataChannel.send(enc)));
            typingTimer = setTimeout(() => showTyping(true), 1000);
        }

        function showTyping(hide) {
            const chat = document.getElementById('chat');
            let typingEl = chat.querySelector('.typing');
            if (hide) {
                if (typingEl) typingEl.remove();
                return;
            }
            if (!typingEl) {
                typingEl = document.createElement('div');
                typingEl.className = 'message typing';
                typingEl.textContent = `${connectedPeer?.username || ''} is typing...`;
                chat.appendChild(typingEl);
                chat.scrollTop = chat.scrollHeight;
            }
        }

        function addMessage(msg, isOwn) {
            const chat = document.getElementById('chat');
            if (chat.querySelector('.typing')) chat.querySelector('.typing').remove();
            const div = document.createElement('div');
            div.className = `message ${isOwn ? 'own' : ''}`;
            div.textContent = `${isOwn ? '' : connectedPeer.username + ': '}${msg}`;
            chat.appendChild(div);
            chat.scrollTop = chat.scrollHeight;
        }

        function updateStatus(text) {
            const status = document.getElementById('status');
            status.style.opacity = 0;
            setTimeout(() => {
                status.textContent = text;
                status.style.opacity = 1;
            }, 300);
        }
    </script>
</body>
</html>
